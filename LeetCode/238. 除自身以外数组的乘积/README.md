# [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

## 题目描述

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

**示例 1：**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**提示**：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明**: 请**不要使用除法**，且在 O(n) 时间复杂度内完成此题。

**进阶**：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

## 解题思路

- 解法一：前后缀乘积之积，本题的关键在于不可以使用除法，同时时间复杂度为 O(n)。

  如果我们通过双层遍历的方式来做，第二层排除自身元素，那样时间复杂度为 O(n2);

  如果先把所有的数字之积求出来在除以自身的话，只有在非0数字存在的时候可行，但是题目要求不使用除法。

  我们可以通过采用空间换时间的方法来保证时间复杂度，提示中有说道 **前缀和后缀之积**，那我们可以想到，分别通过两个数组来表示前缀数组和后缀数组，先求前缀之积以及后缀之积，最后再将前缀之积和后缀之积相乘得到的就是除自身以外的数组乘积。这样时间复杂度为3 * O(n) ,空间复杂度为 2 * O(n)；

  **进阶优化 -> 在常数空间内完成**

  通过上面的分析我们知道，最后是将前缀数组与后缀数组的乘积拷贝到返回数组中，那返回数组除了最后返回个值，也没有用到啊，那不如直接将前缀数组作为返回数组，最后拷贝就直接更新前缀数组就行了，这样空间降低为 O(n), 时间复杂度仍是是 3*O(n)；

  我们再看第三个循环，主要是将前缀与后缀之积更新到前缀数组，那我们直接在第2个循环中当求出后缀数组之后直接更新前缀数组不就完了嘛！同时后缀数组我们只是要当前元素的后缀之积也没必要通过数组存储起来啊？那就直接用变量来动态更新存储就好了啊，这样就将时间复杂度降到了 2 * O(n) ，空间复杂度降到 O(1)了。

## 代码

<!-- tabs:start -->

### **Java**

**解法一：**

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        int[] L = new int[n];
        int[] R = new int[n];
        L[0] = 1;
        R[n - 1] = 1;
        for (int i = 1; i < n; i++) {
            L[i] = L[i - 1] * nums[i - 1];
        }
        for (int i = n - 2; i >= 0; i--) {
            R[i] = R[i + 1] * nums[i + 1];
        }
        for (int i = 0; i < n; i++) {
            res[i] = L[i] * R[i];
        }
        return res;
    }
}
```

**优化**

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        res[0] = 1; 
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }
        int R = 1;
        for (int i = n - 1; i >= 0; i--){
            res[i] *= R;
            R *= nums[i];
        }
        return res;
    }
}
```



### **...**

```

```

<!-- tabs:end -->